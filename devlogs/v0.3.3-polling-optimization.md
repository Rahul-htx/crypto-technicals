# v0.3.3 - Polling Optimization & UI Auto-Refresh

**Date**: August 24, 2025  
**Status**: âœ… Partially Completed  
**Impact**: Major - Reduces disk usage and enables efficient polling

## Problem Statement

1. **Disk Clutter**: Backend was creating a new timestamped folder for every poll cycle (1,701 folders!)
2. **No UI Auto-Refresh**: UI required manual refresh button clicks to see new data
3. **No Polling Control**: Backend polling couldn't be controlled from UI
4. **API Efficiency**: Need to minimize unnecessary CoinGecko API calls

## Solution Implemented

### Phase 1: Folder Structure Optimization âœ…

**Old Approach**: Created timestamped folders for every poll
```
data/runs/
â”œâ”€â”€ 20250823_093048/
â”œâ”€â”€ 20250823_093121/
â”œâ”€â”€ 20250823_093203/
... (1,701 folders!)
```

**New Approach**: Rotating folder structure
```
data/runs/
â”œâ”€â”€ current/        # Latest data
â”œâ”€â”€ previous/       # Previous poll data (n-1)
â”œâ”€â”€ manual_YYYYMMDD/# One-time manual runs
â””â”€â”€ snapshots/      # LLM snapshots (unchanged)
```

### Implementation Details

Modified `src/cli.py`:
- **Serve Mode**: Uses `current/` and `previous/` folders with rotation
- **Manual Runs**: Uses `manual_YYYYMMDD/` format (one per day)
- **Cleanup**: Deleted 1,696 old folders, keeping only essential data

### Benefits
- **Disk Usage**: Reduced from 1,701 folders to 2-3 active folders
- **Performance**: Faster file operations without directory bloat
- **Debugging**: Easy to compare current vs previous data
- **Backup**: Previous folder provides immediate rollback capability

## Phase 2: UI Auto-Refresh âœ…

### Implementation Details âœ…

1. **Status Polling** (UI â†’ Backend)
   ```javascript
   // Check /api/status every 10 seconds
   useEffect(() => {
     const checkForUpdates = async () => {
       const signal = await fetch('/api/status');
       if (signal.hash !== lastStatusHash) {
         await loadSnapshot(); // Auto-refresh data
       }
     };
     const interval = setInterval(checkForUpdates, 10000);
     return () => clearInterval(interval);
   }, [autoRefreshEnabled]);
   ```

2. **Update Signal Flow** (Backend â†’ File â†’ UI)
   ```
   Backend generates snapshot (every 60s)
     â†’ Writes update_signal.json with new hash
     â†’ UI polls /api/status every 10s
     â†’ Detects hash change
     â†’ Auto-refreshes snapshot data
     â†’ Updates prices and timestamps
   ```

3. **User Experience** âœ…
   - âœ… Seamless updates without manual refresh button
   - âœ… Toggle button: "ðŸŸ¢ Auto" / "â­• Manual" 
   - âœ… Works with both auto-polling and manual refreshes
   - âœ… Console logging for debugging: "ðŸ”„ Auto-refresh: New data detected"

## Phase 3: Polling Control âœ…

### Implementation Details âœ…
- **Control API**: Created a new endpoint `/api/control` to receive start/stop commands from the UI.
- **Control File**: The API writes to `polling_control.json`, which the backend reads.
- **Backend Logic**: The Python CLI now checks this file every 2 seconds. If `{"enabled": false}`, it halts the automatic 60s polling timer and only generates snapshots upon manual refresh request.
- **UI Integration**: The "Auto/Manual" button is now fully wired to the `/api/control` endpoint.
- **Default Off**: The system now correctly defaults to manual mode on startup, preventing unwanted API calls.

### Success Criteria
- âœ… No more than 5 folders in `data/runs/`
- âœ… Clean folder rotation without data loss
- âœ… UI auto-refreshes within 10s of new data
- âœ… Polling controllable from UI
- âœ… API calls minimized to necessary updates only

---

**Next Steps**: All phases complete. The system is now stable, efficient, and fully controllable from the UI.
